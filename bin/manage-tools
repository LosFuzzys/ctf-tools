#!/bin/bash
set -eu -o pipefail
# set -x

CTF_TOOLS_ROOT=$(dirname "${BASH_SOURCE[0]}")/..

function usage()
{
	cat <<END
Usage: $(basename $0) [-sv] (list|setup|install|uninstall|bin|search) tool

Where:
    -s      allow running things with sudo (i.e., to install debs)
    -v      verbose mode. print log while installing
    -f      force certain actions (such as installing over an installed tool)
    tool    the name of the tool. if "all", does the action on all tools

Actions:
    setup           set up the environment (adds ctf-tools/bin to your \$PATH in .bashrc)
    list            list all tools (-i: only installed, -u: only uninstalled)
    install         installs a tool
    uninstall       uninstalls a tool
    reinstall       reinstalls a tool
    upgrade         upgrades a tool
    bin             re-links tool binaries into ctf-tools/bin
    search          search description and name of tools
    full-upgrade    upgrade all installed tools

END
}

function tool_log()
{
	echo "$(tput setaf 4 2>/dev/null)TOOLS | $TOOL |$(tput sgr0 2>/dev/null) $@"
}


function tool_log_error()
{
	echo "$(tput setaf 1 2>/dev/null)TOOLS | $TOOL |$(tput sgr0 2>/dev/null) $@"
}

function tool_log_warn()
{
	echo "$(tput setaf 3 2>/dev/null)TOOLS | $TOOL |$(tput sgr0 2>/dev/null) $@"
}

function log()
{
	printf "$(tput setaf 2 2>/dev/null)ctf-tools | $(tput sgr0 2>/dev/null) $@\n"
}

function log_error()
{
	printf "$(tput setaf 1 2>/dev/null)ctf-tools | ERROR: $(tput sgr0 2>/dev/null) $@\n"
}

function log_warn()
{
	printf "$(tput setaf 3 2>/dev/null)ctf-tools | WARNING: $(tput sgr0 2>/dev/null) $@\n"
}


function detect_distribution()
{
	if which pacman >/dev/null 2>&1; then
		echo "archlinux"
	elif which apt-get >/dev/null 2>&1; then
		if lsb_release -a 2>/dev/null | grep -i ubuntu >/dev/null 2>&1; then
			echo "ubuntu"
		else
			echo "debian"
		fi
	elif which dnf >/dev/null 2>&1; then
		echo "fedora"
	else
		echo ""
	fi
}


function base_build_setup_debian()
{
	PACKAGE_REQS="build-essential libtool g++ gcc texinfo curl wget automake autoconf python python-dev git subversion unzip virtualenvwrapper lsb-release"
	PACKAGE_COUNT=$(echo $PACKAGE_REQS | tr ' ' '\n' | wc -l)
	if [ $(dpkg -l $PACKAGE_REQS | grep "^ii" | wc -l) -ne $PACKAGE_COUNT ]
	then
		if [ "$ALLOW_SUDO" -eq 1 ]; then
			sudo apt-get -y install $PACKAGE_REQS
		else
			setup_log "Please install the following packages: $PACKAGE_REQS"
		fi
	fi

	if ! dpkg --print-foreign-architectures | grep -q i386
	then
		if [ "$ALLOW_SUDO" -eq 1 ]
		then
			sudo dpkg --add-architecture i386
			sudo apt-get update
		else
			log_warn "Certain tools need i386 libraries (enable with 'dpkg --add-architecture i386; apt-get update')."
		fi
	fi
}


function base_build_setup_arch()
{
	PACKAGE_REQS="curl wget python2 python3 git subversion unzip python-virtualenvwrapper"
	if [ "$ALLOW_SUDO" -eq 1 ]; then
		sudo pacman -Syu --noconfirm --needed $PACKAGE_REQS
		sudo pacman -Syu --noconfirm --needed base-devel || true
	else
		setup_log "Please install the following packages: $PACKAGE_REQS"
	fi

	if ! grep "^\[multilib\]$" /etc/pacman.conf >/dev/null; then
		if [ "$ALLOW_SUDO" -eq 1 ]; then
			sudo sh -c 'cat >> /etc/pacman.conf' <<EOF

[multilib]
Include = /etc/pacman.d/mirrorlist
EOF
		else
			setup_log "Certain tools need i386 libraries (enable multilib in /etc/pacman.conf')."
			return
		fi
	fi

	if [ "$ALLOW_SUDO" -eq 1 ] \
		&& grep "^\[multilib\]$" /etc/pacman.conf >/dev/null \
		&& ! sudo pacman -Qk gcc-multilib >/dev/null
	then
		sudo pacman -Syy --noconfirm
		#sudo pacman -Syu --noconfirm multilib-devel
		# unfortunately we cannot do --noconfirm if we might choose to replace
		# a package such as gcc with gcc-multilib, therefore this workaround
		printf "\ny\ny\ny\n" | sudo pacman -Syu multilib-devel
	fi
}


function base_build_setup_fedora()
{
	PACKAGE_REQS="libtool gcc gcc-c++ clang cmake texinfo curl wget automake autoconf python python-devel git subversion unzip python-virtualenvwrapper redhat-rpm-config"
	if [ "$ALLOW_SUDO" -eq 1 ]; then
		sudo dnf -y install $PACKAGE_REQS
	else
		setup_log "Please install the following packages: $PACKAGE_REQS"
	fi

	# TODO: check whether we have to explicitly enable i386 package support
}


function base_build_setup()
{
	case "$1" in
		"ubuntu")
			;&  # fallthrough
		"debian")
			base_build_setup_debian
			;;
		"archlinux")
			base_build_setup_arch
			export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3
			;;
		"fedora")
			base_build_setup_fedora
			;;
		*)
			setup_warn "Cannot detect or unsupported distribution - dependencies might be missing"
	esac

	## setup PATH for several shells

	MAGIC="# ctf-tools: PATH setup"
	# make sure at least bashrc exists in case of plain VM setup
	touch ~/.bashrc

	for f in ~/.bashrc ~/.zshrc; do
		if [[ -e "$f" ]]; then
			if ! grep "$MAGIC" "$f" >/dev/null 2>&1; then
				cat >> "$f" << EOF
$MAGIC
export PATH=$PWD/bin:\$PATH
EOF
			fi
		fi
	done

	if [[ -e "$f" ]]; then
		if ! grep "$MAGIC" "$f" >/dev/null 2>&1; then
			cat >> "$f" << EOF
$MAGIC
set -x PATH $PWD/bin \$PATH
EOF
		fi
	fi

	if [[ ! -e "$PWD/bin/ctf-tools-pip3" ]]; then
		ln -s "$PWD/bin/ctf-tools-pip" "$PWD/bin/ctf-tools-pip3"
	fi

	# create the py2 virtualenv
	"$PWD/bin/ctf-tools-pip" freeze 2>&1 >/dev/null

	# create the py3 virtualenv
	"$PWD/bin/ctf-tools-pip3" freeze 2>&1 >/dev/null
}


function is_tool_installed() {
	git status --ignored "$1" | egrep -q 'Untracked|Ignored'
}


function manage_setup() {
	base_build_setup "$DISTRI"
}

function manage_list() {
	for t in *
	do
		[ ! -e "$t/install" ] && continue

		if [[ "$1" == "" ]]; then
			echo "$t"
		else
			if is_tool_installed "$t"; then
				if [[ "$1" == "-i" ]]; then
					echo "$t"
				fi
			else
				if [[ "$1" == "-u" ]]; then
					echo "$t"
				fi
			fi
		fi
	done
}

function manage_bin() {
	pushd "$CTF_TOOLS_ROOT/bin" >/dev/null
	if [ -d ../$TOOL/bin ]; then
		ln -sf ../$TOOL/bin/* .
		tool_log "bin symlinks updated"
	fi
	popd >/dev/null
}

function manage_unbin() {
	pushd "$CTF_TOOLS_ROOT/bin" >/dev/null
	if [ -d ../$TOOL/bin ]; then
		for l in ../$TOOL/bin/*; do
			rm $(basename "$l")
		done
		tool_log "bin symlinks updated"
	fi
	popd >/dev/null
}

function manage_install() {
	pushd "$CTF_TOOLS_ROOT/$TOOL" >/dev/null

	if [ "$FORCE" -eq 0 ] && is_tool_installed "."
	then
		tool_log "appears to already be installed. Uninstall first?"
		exit 0
	fi

	# the first line in all install and uninstall scripts should have the -e flag, otherwise fail
	if [ $(for i in install* uninstall test; do if [ -e "$i" ]; then head -1 "$i"; fi; done | sort | uniq | grep -v '^#!/bin/bash -ex$' | wc -l) -ne 0 ];
	then
		tool_log_error "not all install/uninstall/test scripts start with '#!/bin/bash -ex', which is a must for accurate testing."
		exit 1
	fi

	tool_log "starting install, logging to $PWD/install.log"
	rm -f install.log

	# first get distri specific dependencies
	if [[ $(find . -name 'install-root*' | wc -l) -ge 1 ]]; then
		INSTALL_ROOT_SCRIPT="./install-root-$DISTRI"
		# use debian install script if we are on ubuntu and no ubuntu
		# specific install script exists
		if [[ "$DISTRI" == "ubuntu" \
			&& ! -x "$INSTALL_ROOT_SCRIPT" \
			&& -x "./install-root-debian" ]]
		then
			INSTALL_ROOT_SCRIPT="./install-root-debian"
		fi
		if [[ -x "$INSTALL_ROOT_SCRIPT" && "$ALLOW_SUDO" -eq 1 ]]; then
			if ! sudo env DISTRI=$DISTRI "$INSTALL_ROOT_SCRIPT" >> install.log 2>&1;
			then
				tool_log "INSTALL FAILED"
				cat install.log >&2
				exit 1
			fi
		else
			tool_log_warn "Warning: make sure build dependencies are installed!"
		fi
	fi

	# execute install script
	set +e
	if [ "$VERBOSE_OUTPUT" -eq 1 ]; then
		DISTRI=$DISTRI ./install 2>&1 | tee -a install.log
	else
		DISTRI=$DISTRI ./install >>install.log 2>&1
	fi
	INSTALL_FAILED=$?
	set -e

	if [ "$INSTALL_FAILED" -eq 0 ]; then
		tool_log "install finished"
	else
		tool_log_error "install failed"
		cat install.log >&2
		exit 1
	fi

	popd >/dev/null
}

function manage_uninstall() {
    pushd "$CTF_TOOLS_ROOT/$TOOL" >/dev/null

	local UNINSTALL_FAILED

	tool_log "starting uninstall, logging to $PWD/uninstall.log"
	if [ -x ./uninstall ]; then 
		set +e
		if [ "$VERBOSE_OUTPUT" -eq 1 ]; then
			DISTRI=$DISTRI ./uninstall 2>&1 | tee -a uninstall.log
		else
			DISTRI=$DISTRI ./uninstall >>uninstall.log 2>&1
		fi
		UNINSTALL_FAILED=$?
		set -e

		if [ "$UNINSTALL_FAILED" -ne 0 ]; then
			tool_log_error "uninstall failed"
			cat uninstall.log >&2
			exit 1
		fi
	fi

	git clean -dffx . >/dev/null 2>&1
	tool_log "uninstall finished"

    popd >/dev/null
}


function manage_upgrade() {
	pushd "$CTF_TOOLS_ROOT/$TOOL" >/dev/null

	if is_tool_installed "."; then
		if [ -x ./upgrade ]
		then
			manage_unbin

			set +e
			if [ "$VERBOSE_OUTPUT" -eq 1 ]; then
				DISTRI=$DISTRI ./upgrade 2>&1 | tee -a upgrade.log
			else
				DISTRI=$DISTRI ./upgrade >>upgrade.log 2>&1
			fi
			INSTALL_FAILED=$?
			set -e

			if [ "$INSTALL_FAILED" -eq 0 ]; then
				tool_log "upgrade complete"
			else
				tool_log_error "upgrade failed"
				cat upgrade.log >&2
				exit 1
			fi
			
			manage_bin
		else
			tool_log "no upgrade script -- reinstalling"
			manage_unbin
			manage_uninstall
			manage_install
			manage_bin
			tool_log "upgrade complete!"
		fi
	fi

    popd >/dev/null
}

function manage_reinstall() {
	manage_uninstall
	manage_install 
}

function manage_full_upgrade() {
	log "Upgrading all installed tools!"
	succ=0
	fail=0
	declare -a failed
	installed=$(manage_list -i)
	log "Upgrading tools:\n $installed"
	for t in $installed
	do
		log "Upgrading tool $t"
		TOOL="$t"
		if manage_upgrade; then 
			succ=$((succ+1))
		else
			fail=$((fail+1))
			failed[${#failed[@]}]="$t"
		fi
	done
	log "failed to upgrade ${failed[@]}"
	log "tool full-upgrade stats - sucess=$succ failed=$fail"
}

function manage_search() {
	cat "$CTF_TOOLS_ROOT/README.md" \
        | grep "<\!--tool-->" \
        | sed "s/<\!--[^-]*-->//g" \
        | grep -i "$TOOL"
}

function manage_test() {
	if [ "$FORCE" -eq 0 ] && ! cat README.md | grep "<\!--tool-->" | grep "| \[$TOOL\](" | grep -q -- "--test--"
	then
		tool_log "Tests not enabled."
		if [ "$EXPECTFAIL" -eq "1" ]; then exit 1; fi
	else
		if (
			if ! manage_install; then exit 1; fi

			cd "$CTF_TOOLS_ROOT/$TOOL" || exit 1
			if [ -f "./test" ]
			then
				tool_log "Running test script."
				if ! ./test
				then
					tool_log_error "$TOOL test failed!"
					exit 1
				fi
				tool_log "test script succeeded!"
			else
				tool_log "Install succeeded. No test script!"
			fi
			exit 0
		); 
		then
			if [ "$EXPECTFAIL" -eq "1" ]; then exit 1; else exit 0; fi
		else
			if [ "$EXPECTFAIL" -eq "1" ]; then exit 0; else exit 1; fi
		fi
	fi
}

function manage_dispatch()
{
	pushd "$CTF_TOOLS_ROOT/" >/dev/null

	case $ACTION in
		setup)
			manage_setup
			;;
		list)
            manage_list "${2:-}"
			;;
		bin)
			manage_bin
			;;
		unbin)
			manage_unbin
			;;
		install)
			manage_install
			manage_bin
			;;
		uninstall)
			manage_unbin
			manage_uninstall
			;;
		upgrade)
			if [[ "$TOOL" == "all" ]]; then
				manage_full_upgrade
                exit $?
			else
				manage_upgrade
			fi
			;;
		full-upgrade)
			manage_full_upgrade
			;;
		reinstall)
			manage_reinstall
			;;
		search)
			manage_search
			;;
		test)
			manage_test
			;;
		*)
			log_error "unknown action $ACTION"
			;;
	esac

    popd >/dev/null
}


if [[ $# -eq 0 ]]; then
	usage
	exit 1
fi

DISTRI=$(detect_distribution)

while [[ $1 == -* ]]
do
	case $1 in
		-s)
			export ALLOW_SUDO=1
			;;
		-f)
			export FORCE=1
			;;
		-v)
			export VERBOSE_OUTPUT=1
			;;
		*)
			usage
			exit
			;;
	esac
	shift
done

[[ -z ${ALLOW_SUDO+x} ]] && export ALLOW_SUDO=0
[[ -z ${FORCE+x} ]] && export FORCE=0
[[ -z ${VERBOSE_OUTPUT+x} ]] && export VERBOSE_OUTPUT=0
export EXPECTFAIL=${EXPECTFAIL:-0}

if [[ $# -ge 1 ]]; then
	ACTION="$1"
fi
if [[ $# -eq 2 ]]; then
	TOOL="$2"
else
	TOOL=""
fi

if [ "$TOOL" == "all" ]
then
	for t in $(manage_list "-i")
	do
		TOOL="$t"
		manage_dispatch "$@"
	done
elif [ -z "$TOOL" -a "$ACTION" != "list" -a "$ACTION" != "setup" -a "$ACTION" != "full-upgrade" ]
then
	usage
	exit
fi

manage_dispatch "$@"
